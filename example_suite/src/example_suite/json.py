from typing import Any


def dumps(value: Any) -> str:
    """Serialize a limited subset of Python values to JSON.

    Supported types: None, float (finite), str, list, dict[str, Any].
    """
    if value is None:
        return "null"
    if isinstance(value, bool):
        # Not generated by the strategy, but easy to support
        return "true" if value else "false"
    if isinstance(value, (int, float)):
        # Floats in the strategy are finite; ensure float roundtrip
        if isinstance(value, bool):  # bool is subclass of int
            return "true" if value else "false"
        if isinstance(value, int):
            return str(value)
        # Use repr for precise roundtrips like -0.0
        return repr(value)
    if isinstance(value, str):
        return '"' + _escape_string(value) + '"'
    if isinstance(value, list):
        return "[" + ",".join(dumps(item) for item in value) + "]"
    if isinstance(value, dict):
        items: list[str] = []
        for key, val in value.items():
            if not isinstance(key, str):
                raise TypeError("JSON object keys must be strings")
            items.append('"' + _escape_string(key) + '"' + ":" + dumps(val))
        return "{" + ",".join(items) + "}"
    raise TypeError(f"Type not supported for JSON serialization: {type(value)!r}")


def loads(s: str) -> Any:
    """Parse a JSON string into Python values for the supported subset."""
    parser = _Parser(s)
    value = parser.parse_value()
    parser.skip_ws()
    if not parser.eof():
        parser.error("Extra data after valid JSON value")
    return value


def _escape_string(s: str) -> str:
    out_chars: list[str] = []
    for ch in s:
        code = ord(ch)
        if ch == '"':
            out_chars.append('\\"')
        elif ch == "\\":
            out_chars.append("\\\\")
        elif ch == "\b":
            out_chars.append("\\b")
        elif ch == "\f":
            out_chars.append("\\f")
        elif ch == "\n":
            out_chars.append("\\n")
        elif ch == "\r":
            out_chars.append("\\r")
        elif ch == "\t":
            out_chars.append("\\t")
        elif code < 0x20:
            out_chars.append(f"\\u{code:04x}")
        else:
            out_chars.append(ch)
    return "".join(out_chars)


class _Parser:
    def __init__(self, source: str) -> None:
        self.s = source
        self.i = 0

    def eof(self) -> bool:
        return self.i >= len(self.s)

    def current(self) -> str:
        return self.s[self.i]

    def advance(self, n: int = 1) -> None:
        self.i += n

    def skip_ws(self) -> None:
        while not self.eof() and self.s[self.i] in " \t\n\r":
            self.i += 1

    def error(self, msg: str) -> None:
        # Simple error with position info
        raise ValueError(f"{msg} at position {self.i}")

    def expect(self, literal: str) -> None:
        if not self.s.startswith(literal, self.i):
            self.error(f"Expected {literal!r}")
        self.i += len(literal)

    def parse_value(self) -> Any:
        self.skip_ws()
        if self.eof():
            self.error("Unexpected end of input")
        ch = self.current()
        if ch == "n":
            self.expect("null")
            return None
        if ch == "t":
            self.expect("true")
            return True
        if ch == "f":
            self.expect("false")
            return False
        if ch == '"':
            return self.parse_string()
        if ch == "[":
            return self.parse_array()
        if ch == "{":
            return self.parse_object()
        if ch == "-" or ch.isdigit():
            return self.parse_number()
        self.error(f"Unexpected character {ch!r}")

    def parse_string(self) -> str:
        assert self.current() == '"'
        self.advance()  # skip opening quote
        chars: list[str] = []
        while not self.eof():
            ch = self.current()
            if ch == '"':
                self.advance()
                return "".join(chars)
            if ch == "\\":
                self.advance()
                if self.eof():
                    self.error("Unterminated escape sequence in string")
                esc = self.current()
                self.advance()
                if esc == '"':
                    chars.append('"')
                elif esc == "\\":
                    chars.append("\\")
                elif esc == "/":
                    chars.append("/")
                elif esc == "b":
                    chars.append("\b")
                elif esc == "f":
                    chars.append("\f")
                elif esc == "n":
                    chars.append("\n")
                elif esc == "r":
                    chars.append("\r")
                elif esc == "t":
                    chars.append("\t")
                elif esc == "u":
                    # Parse four hex digits
                    if self.i + 4 > len(self.s):
                        self.error("Incomplete unicode escape")
                    hex_digits = self.s[self.i : self.i + 4]
                    try:
                        code = int(hex_digits, 16)
                    except ValueError:
                        self.error("Invalid unicode escape")
                    chars.append(chr(code))
                    self.advance(4)
                else:
                    self.error(f"Invalid escape character {esc!r}")
            else:
                # Control characters are not allowed in JSON strings
                if ord(ch) < 0x20:
                    self.error("Unescaped control character in string")
                chars.append(ch)
                self.advance()
        self.error("Unterminated string")

    def parse_array(self) -> list[Any]:
        assert self.current() == "["
        self.advance()  # skip [
        self.skip_ws()
        items: list[Any] = []
        if not self.eof() and self.current() == "]":
            self.advance()
            return items
        while True:
            item = self.parse_value()
            items.append(item)
            self.skip_ws()
            if self.eof():
                self.error("Unterminated array")
            ch = self.current()
            if ch == ",":
                self.advance()
                self.skip_ws()
                continue
            if ch == "]":
                self.advance()
                return items
            self.error("Expected ',' or ']' in array")

    def parse_object(self) -> dict[str, Any]:
        assert self.current() == "{"
        self.advance()  # skip {
        self.skip_ws()
        obj: dict[str, Any] = {}
        if not self.eof() and self.current() == "}":
            self.advance()
            return obj
        while True:
            self.skip_ws()
            if self.eof() or self.current() != '"':
                self.error("Expected string key in object")
            key = self.parse_string()
            self.skip_ws()
            if self.eof() or self.current() != ":":
                self.error("Expected ':' after object key")
            self.advance()
            value = self.parse_value()
            obj[key] = value
            self.skip_ws()
            if self.eof():
                self.error("Unterminated object")
            ch = self.current()
            if ch == ",":
                self.advance()
                self.skip_ws()
                continue
            if ch == "}":
                self.advance()
                return obj
            self.error("Expected ',' or '}' in object")

    def parse_number(self) -> Any:
        start = self.i
        ch = self.current()
        if ch == "-":
            self.advance()
            if self.eof() or not self.current().isdigit():
                self.error("Invalid number")
        if self.current() == "0":
            self.advance()
        else:
            while not self.eof() and self.current().isdigit():
                self.advance()
        is_float = False
        if not self.eof() and self.current() == ".":
            is_float = True
            self.advance()
            if self.eof() or not self.current().isdigit():
                self.error("Invalid fractional part in number")
            while not self.eof() and self.current().isdigit():
                self.advance()
        if not self.eof() and self.current() in "eE":
            is_float = True
            self.advance()
            if not self.eof() and self.current() in "+-":
                self.advance()
            if self.eof() or not self.current().isdigit():
                self.error("Invalid exponent in number")
            while not self.eof() and self.current().isdigit():
                self.advance()
        num_str = self.s[start : self.i]
        try:
            return (
                float(num_str)
                if is_float or ("." in num_str) or ("e" in num_str) or ("E" in num_str)
                else int(num_str)
            )
        except ValueError:
            self.error("Invalid number literal")
